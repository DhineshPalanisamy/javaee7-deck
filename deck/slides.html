<!DOCTYPE html><html lang="en" class="aspect-16-9"><head><meta charset="UTF-8" /><meta name="generator" content="Asciidoctor 1.5.0.preview.1, dzslides backend" /><title>The Java EE 7 Platform</title><meta name="author" content="Arun Gupta" /><link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Neuton:400,700,800,400italic|Cedarville+Cursive" /><link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/font-awesome/3.2.1/css/font-awesome.min.css" /><link rel="stylesheet" href="./dzslides/themes/highlight/asciidoctor.css" /><link rel="stylesheet" href="./dzslides/themes/style/asciidoctor.css" /><style>section:not(.topic) > h2 { display: none;}</style><link rel="stylesheet" href="./dzslides/core/dzslides.css" /><link rel="stylesheet" href="./dzslides/themes/transition/fade.css" /></head><body><section class="title"><h1>The Java EE 7 Platform</h1><footer><span class="author">Arun Gupta</span><span class="divider">&nbsp;&middot;&nbsp;</span><span class="author">Red Hat</span><span class="divider">&nbsp;&middot;&nbsp;</span><span class="author">@arungupta</span></footer></section><section class="topic source"><h2>Arun Gupta</h2><div class="exampleblock"><div class="content"><ul><li>Director, Developer Advocacy, Red Hat Inc.</li><li>O&#8217;Reilly and McGraw Hill author</li><li>Fitness freak</li></ul></div></div>
<details><details open=""><summary>Notes</summary><ul><li>My name is Arun Gupta, and I drive community engagement efforts for JBoss at Red Hat</li><li>I&#8217;ve authored couple of O&#8217;Reilly best selling books and another one by McGraw Hill</li><li>I&#8217;m a workout nut as my kids call me and a runner</li></ul></details></details></section>
<section class="topic source"><h2>Java EE 7 Platform</h2><p><span class="image"><img src="images/java-logo.png" alt="java-logo" /></span>
=== Jun 2013</p>
<details><details open=""><summary>Notes</summary><ul><li>Java EE 7 was released in June 2013. That means all 14 component specifications are final, the Reference Implementation is final, and TCK is available for licensees for building their compliant app servers.</li></ul></details></details></section>
<section class="topic source"><h2>Java EE 7</h2><img src="images/javaee7.png" alt="javaee7" />
<details><details open=""><summary>Notes</summary><ul><li>Java EE 7 is the latest release of the platform and focuses around increasing productivity and embracing HTML5. WildFly 8 is Java EE 7 compliant and so you get all the technologies from the platform here.</li><li>WebSocket (JSR 356), Batch (JSR 352), JSON (JSR 353), Concurrency Utilities for Java EE (JSR 236) are four new techonlogies in the platform. JAX-RS 2 (JSR 339) and JMS 2 (JSR 343) went through significant updates. CDI 1.1 (JSR 346), Bean Validation 1.1 (JSR 349), JPA 2.1 (JSR 338), JTA 1.2 (JSR 907) also made updates.</li><li>Lets take a look at some Java EE 7 sample code.</li></ul></details></details></section>
<section class="topic source"><h2>Java EE 7 WebSocket</h2><div class="listingblock"><div class="title"><code>ChatServer.java</code></div><pre class="highlight CodeRay"><code class="java">@ServerEndpoint("/chat") <i class="conum" data-value="1"></i><b>(1)</b>
public class ChatEndpoint {
    @OnMessage <i class="conum" data-value="2"></i><b>(2)</b>
    public void message(String message,
                        Session client) <i class="conum" data-value="3"></i><b>(3)</b>
                   throws IOException, EncodeException {
        for (Session peer : client.getOpenSessions()) {
            peer.getBasicRemote().sendText(message);
        }
    }
}</code></pre></div>
<div class="colist arabic"><table><tr><td><i class="conum" data-value="1"></i><b>1</b></td><td>Creates a WebSocket endpoint, defines the listening URL</td></tr><tr><td><i class="conum" data-value="2"></i><b>2</b></td><td>Marks the method that receives incoming WebSocket message</td></tr><tr><td><i class="conum" data-value="3"></i><b>3</b></td><td>Payload of the WebSocket message</td></tr></table></div>
<details><details open=""><summary>Notes</summary><ul><li>The Java API for WebSocket, WebSocket 1.0, is a key technology for HTML5 support. WebSocket provides a bi-directional and full-duplex communication channel over a sigle TCP connection.</li><li>Adding <code>@ServerEndpoint</code> annotation on a POJO converts it into a WebSocket server endpoint. No additional deployment descriptors are required. The URL at which the endpoint is published is included in the annotation.</li><li>The POJO method that needs to be invoked is marked with <code>@OnMessage</code> and the payload of the message is automatically mapped to the method parameter.</li><li>First parameter receives the payload, second parameter marks the conversation from the client.</li><li>Method implementation iterate over all the connected clients and broadcast the received payload.</li></ul></details></details></section>
<section class="topic source"><h2>Java EE 7 Batch</h2><div class="listingblock"><div class="title"><code>job.xml</code></div><pre class="highlight CodeRay"><code class="xml">&lt;job id="myJob" xmlns="http://xmlns.jcp.org/xml/ns/javaee" version="1.0"&gt;
    &lt;step id="myStep" &gt;
        &lt;chunk item-count="3"&gt; <i class="conum" data-value="1"></i><b>(1)</b>
            &lt;reader ref="myItemReader"/&gt; <i class="conum" data-value="2"></i><b>(2)</b>
            &lt;processor ref="myItemProcessor"/&gt; <i class="conum" data-value="3"></i><b>(3)</b>
            &lt;writer ref="myItemWriter"/&gt; <i class="conum" data-value="4"></i><b>(4)</b>
        &lt;/chunk&gt;
    &lt;/step&gt;
&lt;/job&gt;</code></pre></div>
<div class="colist arabic"><table><tr><td><i class="conum" data-value="1"></i><b>1</b></td><td>Item-oriented processing, number of items in chunk</td></tr><tr><td><i class="conum" data-value="2"></i><b>2</b></td><td>Item reader for chunk processing</td></tr><tr><td><i class="conum" data-value="3"></i><b>3</b></td><td>Item processor for chunk processing</td></tr><tr><td><i class="conum" data-value="4"></i><b>4</b></td><td>Item writer for chunk processing</td></tr></table></div>
<details><details open=""><summary>Notes</summary><ul><li>Batch Processing provides item-oriented (aka chunk, and preferred style) and task-oriented (aka batchlet) processing. This is a job description of chunk processing, aka Job XML.</li><li>Job XML typically consists of many steps, this canonical sample contains one chunk step.</li><li>This chunk has a reader, processor, and writer. The ref attribute refers to CDI resolvable bean name bundled with the archive.</li><li>The item-count attribute defines the chunk size, i.e. the number of items processed at one time.</li><li>The reader, processor, and writer work together for a chunk number of items at a time.</li><li>All of this is done within a transaction, with automatic checkpointing.</li></ul></details></details></section>
<section class="topic source"><h2>Java EE 7 JSON</h2><div class="listingblock"><div class="title"><code>CreateJson.java</code></div><pre class="highlight CodeRay"><code class="java">JsonObject jsonObject = Json.createObjectBuilder() <i class="conum" data-value="1"></i><b>(1)</b>
                .add("apple", "red") <i class="conum" data-value="2"></i><b>(2)</b>
                .add("banana", "yellow")
                .build(); <i class="conum" data-value="3"></i><b>(3)</b>
StringWriter w = new StringWriter();
JsonWriter writer = Json.createWriter(w); <i class="conum" data-value="4"></i><b>(4)</b>
writer.write(jsonObject);</code></pre></div>
<div class="colist arabic"><table><tr><td><i class="conum" data-value="1"></i><b>1</b></td><td>Creates a JSON object builder</td></tr><tr><td><i class="conum" data-value="2"></i><b>2</b></td><td>Adds a name/value pair to the JSON object</td></tr><tr><td><i class="conum" data-value="3"></i><b>3</b></td><td>Returns the JSON object associated with this builder</td></tr><tr><td><i class="conum" data-value="4"></i><b>4</b></td><td>Writes the JSON object to the writer</td></tr></table></div>
<details><details open=""><summary>Notes</summary><ul><li>JSON is a key technology for data transfer within HTML5 applications. With JSON 1.0, Java EE 7 adds new APIs to enable the parsing and generation of JSON text and objects.</li><li>JSON API provides streaming and object model API to parse and generate JSON. This is an object-model API sample.</li><li><code>JSONObject</code> is created and key/value name pairs are added using convenient <code>add</code> methods.</li><li>Created object can be written to <code>java.io.Writer</code> or <code>java.io.OutputStream</code>.</li></ul></details></details></section>
<section class="topic source"><h2>Java EE 7 Concurrency</h2><div class="listingblock"><div class="title"><code>RunMyTask.java</code></div><pre class="highlight CodeRay"><code class="java">public class MyTask implements Runnable { <i class="conum" data-value="1"></i><b>(1)</b>

    @Override
    public void run() {
        . . .
    }
}

@Resource(name = "DefaultManagedExecutorService") <i class="conum" data-value="2"></i><b>(2)</b>
ManagedExecutorService defaultExecutor;

executor.submit(new MyTask()); <i class="conum" data-value="3"></i><b>(3)</b></code></pre></div>
<div class="colist arabic"><table><tr><td><i class="conum" data-value="1"></i><b>1</b></td><td><code>Runnable</code> or <code>Callable</code> tasks can be submitted</td></tr><tr><td><i class="conum" data-value="2"></i><b>2</b></td><td><code>ManagedExecutor</code> is injected, default resource provided</td></tr><tr><td><i class="conum" data-value="3"></i><b>3</b></td><td>Submit the task</td></tr></table></div>
<details><details open=""><summary>Notes</summary><ul><li>Concurrency Utilities is a new addition to the Java EE 7 platform and is an extension of the Java SE Concurrency Utilities API. This API provides asynchronous capabilities to Java EE application components, at a lower level than the existing asynch APIs (offered by EJB, Servlet, JAX-RS), and thus gives you a finer-grain level of control and configuration.</li><li>API provides 4 types of managed objects, one of them is <code>ManagedExecutorService</code>.</li><li>Task can be defined as <code>Runnable</code> or <code>Callable</code>.</li><li>Platform provides a default instance of <code>ManagedExecutorService</code> which can be easily injected using <code>@Resource</code>.</li><li>Usual calls from JSR 166y are now available. All standard Java SE Concurrency APIs and design patterns are available for us. The big difference is that the threads created here are managed by the application server now. The JNDI, class loading, security context information is available to these tasks. This was not available earlier.</li></ul></details></details></section>
<section class="topic source"><h2>Java EE 7 JAX-RS</h2><div class="listingblock"><div class="title"><code>RunClient.java</code></div><pre class="highlight CodeRay"><code class="java">Client client = ClientBuilder.newClient(); <i class="conum" data-value="1"></i><b>(1)</b>
WebTarget target = client.target(...); <i class="conum" data-value="2"></i><b>(2)</b>
target.register(Person.class);
Person p = target
             .path("{id}") <i class="conum" data-value="3"></i><b>(3)</b>
             .resolveTemplate("id", "1")
             .request(MediaType.APPLICATION_XML) <i class="conum" data-value="4"></i><b>(4)</b>
             .get(Person.class); <i class="conum" data-value="5"></i><b>(5)</b></code></pre></div>
<div class="colist arabic"><table><tr><td><i class="conum" data-value="1"></i><b>1</b></td><td><code>ClientBuilder</code> is the entry point</td></tr><tr><td><i class="conum" data-value="2"></i><b>2</b></td><td>Build a new web resource target, specifies the path</td></tr><tr><td><i class="conum" data-value="3"></i><b>3</b></td><td>Sub resource URI</td></tr><tr><td><i class="conum" data-value="4"></i><b>4</b></td><td>Define the accepted response media types</td></tr><tr><td><i class="conum" data-value="5"></i><b>5</b></td><td>Call HTTP GET, specify the type of resource</td></tr></table></div>
<details><details open=""><summary>Notes</summary><ul><li>JAX-RS 2.0 now adds a client-side API to access a REST endpoint in a standard way.</li><li>An instance of <code>Client</code> is required to access a Web resource using the Client API. The default instance of Client can be obtained by calling newClient on <code>ClientBuilder</code>.</li><li>A Web resource can be accessed using a fluent API in which method invocations are chained to build and ultimately submit an HTTP request.</li><li>Conceptually, the steps required to submit a request are the following:<ul><li>obtain an instance of <code>Client</code></li><li>create a <code>WebTarget</code></li><li>create a request from the <code>WebTarget</code></li><li>submit a request or get a prepared Invocation for later submission</li></ul></li><li>The benefits of using a <code>WebTarget</code> become apparent when building complex URIs, for example by ex- tending base URIs with additional path segments or templates. Note the use of the URI template parameter <code>{orderId}</code>. The exact value of this template parameter is resolved using <code>resolveTemplate()</code> method.</li><li>The response to a request typed in the invocation of <code>get()</code> method. In this case, a String representation is returned back. This can also be a POJO where on-the-wire format is converted to POJO using JAX-RS entity providers.</li></ul></details></details></section>
<section class="topic source"><h2>Java EE 7 JMS</h2><div class="listingblock"><div class="title"><code>SendMessage.java</code></div><pre class="highlight CodeRay"><code class="java">@JMSDestinationDefinition(name="myQueue", interfaceName="javax.jms.Queue") <i class="conum" data-value="1"></i><b>(1)</b>

@Resource(mappedName="myQueue")
Queue syncQueue;

@Inject
// @JMSConnectionFactory("java:comp/DefaultJMSConnectionFactory") <i class="conum" data-value="2"></i><b>(2)</b>
private JMSContext context; <i class="conum" data-value="3"></i><b>(3)</b>

context.createProducer().send(syncQueue, "..."); <i class="conum" data-value="4"></i><b>(4)</b></code></pre></div>
<div class="colist arabic"><table><tr><td><i class="conum" data-value="1"></i><b>1</b></td><td>Create destination resource during deployment</td></tr><tr><td><i class="conum" data-value="2"></i><b>2</b></td><td>Default JMS connection factory</td></tr><tr><td><i class="conum" data-value="3"></i><b>3</b></td><td>Main interface of the simplified API</td></tr><tr><td><i class="conum" data-value="4"></i><b>4</b></td><td>Fluent builder API, runtime exceptions</td></tr></table></div>
<details><details open=""><summary>Notes</summary><ul><li>JMS has undergone a major simplification with the JMS 2.0 by offering the simple and easier-to-use API and  offloading developer tasks onto container services.</li><li>Sending and receiving a message using JMS 1.1 required a lot of boilerplate code. JMS 2.0 has really fixed this with the addition of the new JMS simplified API and, in particular, the <code>JMSContext</code> interface.</li><li><code>JMSContext</code> combines in a single object the functionality of both the <code>Connection</code> and the <code>Session</code> in the earlier JMS APIs. A container-managed <code>JMSContext</code> instance can be obtained by simply injecting it with the <code>@Inject</code> annotation. Notice, no <code>ConnectionFactory</code> is specified here. In this case, a default JMS ConnectionFactory is used by and this is defined by the platform.</li><li>A <code>Destination</code>, a <code>Queue</code> in this case, is injected using <code>@Resource</code>. Even this annotation can be created using newly introduced <code>@JMSDestinationDefintion</code> annotation which would automatically create the destination.* Finally, the message is sent using method chaining. For example, create a producer using <code>createProducer()</code> and then calling <code>send()</code> method to send a message to a destination.</li><li>Really simple and clean. This also improves semantic readability of your code.</li></ul></details></details></section>
<section class="topic source"><h2>Java EE 7 IDEs</h2><p><span class="image"><img src="images/netbeans-wildfly.png" alt="netbeans-wildfly" /></span> <span class="image"><img src="images/eclipse-wildfly.png" alt="eclipse-wildfly" /></span> <span class="image"><img src="images/intellij-wildfly.png" alt="intellij-wildfly" /></span>
<span class="image"><img src="images/netbeans-logo.png" alt="netbeans-logo" /></span> <span class="image"><img src="images/jbosstools-logo.png" alt="jbosstools-logo" /></span> <span class="image"><img src="images/intellij-logo.png" alt="intellij-logo" /></span></p></section>
<section class="topic source"><h2>References</h2><div class="admonitionblock note"><table><tr><td class="icon"><i class="icon-note" title="Note"></i></td><td class="content">Java EE 7 samples - <a href="https://github.com/javaee-samples/javaee7-samples">https://github.com/javaee-samples/javaee7-samples</a></td></tr></table></div>
<div class="admonitionblock note"><table><tr><td class="icon"><i class="icon-note" title="Note"></i></td><td class="content">Reference Implemenation: GlassFish - <a href="http://glassfish.org">http://glassfish.org</a>, @glassfish</td></tr></table></div>
<div class="admonitionblock note"><table><tr><td class="icon"><i class="icon-note" title="Note"></i></td><td class="content">WildFly - <a href="http://wildfly.org">http://wildfly.org</a>, <a href="http://github.com/wildfly">http://github.com/wildfly</a>, @WildFlyAS</td></tr></table></div>
<div class="admonitionblock note"><table><tr><td class="icon"><i class="icon-note" title="Note"></i></td><td class="content">Slides generated with Asciidoctor and DZSlides backend</td></tr></table></div>
<div class="admonitionblock note"><table><tr><td class="icon"><i class="icon-note" title="Note"></i></td><td class="content">Original slide template - Dan Allen &amp; Sarah White</td></tr></table></div></section>
<section class="topic ending"><h2 class="name">Arun Gupta</h2><p class="footer"><em class="icon-twitter">&#8203;</em> @arungupta</p></section><script src="./dzslides/core/dzslides.js"></script><script src="./dzslides/highlight/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad()</script></body></html>